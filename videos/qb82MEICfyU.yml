# Editing guidelines: https://github.com/watch-devtube/contrib/#how-to-edit-video-metadata

tags:
    - ruby
    - lisp
    - java
title: 'RubyConf 2010 - Objects are Just Objects, Aren''t they? by: Rick DeNatale'
recordingDate: 1428421120
description: 'For almost 30 years, it has been conventional wisdom that objects in an "object-oriented" programming language were somehow the same, whether that language was C++ or Smalltalk, Java or Ruby, etc. One of the headwaters of this wisdom was the OOPSLA ''87 paper by Peter Wegner "Dimensions of Object-Based Language Design" which surveyed the ''hot'' language features of those days including classes, inheritance, delegation, prototypes, and abstract data types. Among other things it defined an object oriented language as one with object, classes, and inheritance, a definition with subtle but important differences from the definition intended by Alan Kay when HE coined the term "object-oriented," some 20 years previously. This paper gave many readers the false impression of more unification of these concepts than existed in reality. In some ways it created a kind of "Tower of Babel" effect, by confounding communication by making us think we were speaking the same language when we really were not. More recently, one of Wegner''s students, William Cook, perhaps in a moment of apostasy drafted a paper http://userweb.cs.utexas.edu/~wcook/Drafts/2009/essay.pdf which exposes the truth which some of us have known all these years, that there is a vast difference between Abstract Data Types and Objects. As a result, a great number of today''s practitioners labor under false beliefs, that there are (nearly) universal approaches to "object-oriented" design, many of these coming from languages based on Abstract Data Types, primarily C++ and other statically typed languages. What does this mean to Ruby programmers? Ruby is an Object Oriented language in the true sense of the word, and not an ADT language. This talk will discuss the differences between ADTs and Objects; touch on the connections between closures from languages such as Lisp and Scheme, and true objects; and explore the pragmatic consequences for the Rubyist.'
